#!/bin/bash

# ----------------------------------------------------------------------------------------
# Dotfiles setup stuff
# ----------------------------------------------------------------------------------------

# Put handlers on PATH
[ -d "$HOME/.dotfiles/handlers" ] && export PATH="$PATH:$HOME/.dotfiles/handlers::"

# Put utils on PATH
[ -d "$HOME/.dotfiles/utils" ] && export PATH="$PATH:$HOME/.dotfiles/utils::"

# Use this customrc file to put all your custom stuff without changing the existing
# setup of the main bashrc file.
[ -f "$HOME/.dotfiles/files/customrc" ] && source "$HOME/.dotfiles/files/customrc"

# ----------------------------------------------------------------------------------------
# Global OS/Hardware Specific/History
# ----------------------------------------------------------------------------------------

# Fix keyboard US International layout for supporting multiple languages
# use this only when using Brazilian-Portuguese should be used along with English
[ -f "$(whereis setxkbmap | awk '{ print $2 }')" ] && setxkbmap -model pc104 -layout us_intl

# Vim setup
set -o vi 

if [ -f "$(whereis vim | awk '{ print $2 }')" ] ; then 
    export EDITOR=vim
    alias vi="vim"
else 
    EDITOR=vi
fi

# don't put duplicate lines or lines starting with space in bash history
export HISTCONTROL=ignoredups:erasedups

# append to the history file, don't overwrite it
shopt -s histappend

# for setting history length see HISTSIZE and HISTFILESIZE in bash(1)
HISTSIZE=
HISTFILESIZE=

# Enable cdspell for spell-checking
shopt -s cdspell

# check the window size after each command and, if necessary,
# update the values of LINES and COLUMNS.
shopt -s checkwinsize

# ----------------------------------------------------------------------------------------
# Pet Snippets / Fuzzy Search / GoFish
# ----------------------------------------------------------------------------------------

# GoFish source
[ -f "$(whereis gofish | awk '{ print $2 }')" ] && eval "$(gofish tank)"

# Fuzzy search sourcing
[ -f ~/.dotfiles/files/fzf.bash ] && source ~/.dotfiles/files/fzf.bash

# Select commands from Pet snippet list
function pet-select() {
  BUFFER=$(pet search --query "$READLINE_LINE")
  READLINE_LINE=$BUFFER
  READLINE_POINT=${#BUFFER}
}

# Add Previous command to Pet
function prev() {
  PREV=$(echo `history | tail -n2 | head -n1` | sed 's/[0-9]* //')
  sh -c "pet new `printf %q "$PREV"`"
}

# Keybinding: Execute commands from Pet selection (CTRL-X + CTRL-X)
bind -x '"\C-x\C-x": pet-select'

# Keybinding: Fuzzy Vim Open files from current directory (CTRL-X + CTRL-O)
bind -x '"\C-x\C-o": vim $(fzf --height 40%)'

# Keybinding: Fuzzy search from current directory (CTRL-X + CTRL-F)
bind -x '"\C-x\C-f": fzf --height 40%'

# ----------------------------------------------------------------------------------------
# CLI auto-completes
# ----------------------------------------------------------------------------------------

[ -f "$(whereis kubectl | awk '{ print $2 }')" ] && source <(kubectl completion bash)
[ -f "$(whereis helm | awk '{ print $2 }')" ] && source <(helm completion bash)
[ -f /usr/local/ibmcloud/bx/bash_autocomplete ] && . /usr/local/ibmcloud/bx/bash_autocomplete
[ -f /etc/bash_completion.d/mvn ] && . /etc/bash_completion.d/mvn

# ----------------------------------------------------------------------------------------
# Aliases, Functions & Productivity Hacks
# ----------------------------------------------------------------------------------------

# BAU stuff and some string manipulation handlers
alias more=less
alias ls='ls --color=tty'
alias ll='ls -ltr'
alias lsh='ls -lhXG' # Long human readable
alias bashrc='source ~/.bashrc'
alias dos2unix='perl -pi -e "tr/\r//d"'
alias unix2dos='perl -pi -e "s/\n$/\r\n/g"'
alias mac2unix='perl -pi -e "tr/\r/\n/d"'
alias root="sudo su -"
alias igrep='grep -i'
alias mkdir='mkdir -p'
alias cd..='cd ..'
alias ..='cd ..'
alias ...='cd ../..'
alias ....='cd ../../..'
alias .....='cd ../../../..'
alias .5='cd ../../../../..'
alias .6='cd ../../../../../..'
alias prettyjson='python -m json.tool'

# Source Kubectl aliases (https://github.com/ahmetb/kubectl-aliases)
[ -f "$PWD/files/.kubectl_aliases" ] && source "$PWD/files/.kubectl_aliases"

# Change Kubernetes namespace context
alias kcd='kubectl config set-context $(kubectl config current-context) --namespace '

# Start tmux with uniq name
[ -f "$HOME/.tmux.conf" ] && alias tmuxnew='tmux new -s $(whoami)-$(date "+%Y-%m-%d_%H%M%S")'

# Read The Freaking Manual (or Google it)
rtfm() { "$@" --help 2> /dev/null || man "$@" 2> /dev/null || google-chrome "http://www.google.com/search?q=$@"; }

# Count chars of a string from command line
function len {
    printf $1 | wc -c
}

# Convert epoch time to human readable format from command line
function epoch {
    date -d @$(($1 / 1000))
}

# Response time of URL (Timeconnect, timetransfer, timetoal)
function curltime {
  echo "time_connect, time_starttransfer, time_total"
  curl -o /dev/null -s -w "%{time_connect} + %{time_starttransfer} = %{time_total}\n" "$1"
  }

# ----------------------------------------------------------------------------------------
# Terminal Color/Schemes
# ----------------------------------------------------------------------------------------

# Colorful man pages
export LESS_TERMCAP_mb="$(printf '\e[01;31m')"    # enter blinking mode – red
export LESS_TERMCAP_md="$(printf '\e[01;35m')"    # enter double-bright mode – bold, magenta
export LESS_TERMCAP_me="$(printf '\e[0m')"        # turn off all appearance modes (mb, md, so, us)
export LESS_TERMCAP_se="$(printf '\e[0m')"        # leave standout mode
export LESS_TERMCAP_so="$(printf '\e[01;33m')"    # enter standout mode – yellow
export LESS_TERMCAP_ue="$(printf '\e[0m')"        # leave underline mode
export LESS_TERMCAP_us="$(printf '\e[04;36m')"    # enter underline mode – cyan 

# Syntax highlight for LESS command

if [ -f "$(whereis source-highlight | awk '{ print $2 }')" ]; then
    export PAGER="less"
    export LESS="-R"
    [ -f "$HOME/.dotfiles/utils/src-hilite-lesspipe.sh" ] && export LESSOPEN="| $HOME/.dotfiles/utils/src-hilite-lesspipe.sh %s"
fi

# make less more friendly for non-text input files, see lesspipe(1)
[ -f /usr/bin/lesspipe ] && eval "$(SHELL=/bin/sh lesspipe)"

# cat syntax highlight
alias pcat='source-highlight --failsafe -f esc --lang-def=makefile.lang --style-file=esc.style -i '

# enable color support of ls and also add handy aliases
if [ -x /usr/bin/dircolors ]; then
    test -r ~/.dircolors && eval "$(dircolors -b ~/.dircolors)" || eval "$(dircolors -b)"
    alias ls='ls --color=auto'
    alias dir='dir --color=auto'
    alias vdir='vdir --color=auto'
    alias grep='grep --color=auto'
    alias fgrep='fgrep --color=auto'
    alias egrep='egrep --color=auto'
fi

# set a fancy prompt (non-color, unless we know we "want" color)
case "$TERM" in
    xterm-color) color_prompt=yes;;
esac

# uncomment for a colored prompt, if the terminal has the capability; turned
# off by default to not distract the user: the focus in a terminal window
# should be on the output of commands, not on the prompt
force_color_prompt=yes

if [ -n "$force_color_prompt" ]; then
    if [ -x /usr/bin/tput ] && tput setaf 1 >&/dev/null; then
	# We have color support; assume it's compliant with Ecma-48
	# (ISO/IEC-6429). (Lack of such support is extremely rare, and such
	# a case would tend to support setf rather than setaf.)
	color_prompt=yes
    else
	color_prompt=
    fi
fi

if [ "$color_prompt" = yes ]; then
    PS1='${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ '
else
    PS1='${debian_chroot:+($debian_chroot)}\u@\h:\w\$ '
fi
unset color_prompt force_color_prompt

# ------------------------------------------------------------------------------------------------
# END OF FILE
# ------------------------------------------------------------------------------------------------
